// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: paymentrequest.proto

#ifndef PROTOBUF_INCLUDED_paymentrequest_2eproto
#define PROTOBUF_INCLUDED_paymentrequest_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_paymentrequest_2eproto 

namespace protobuf_paymentrequest_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_paymentrequest_2eproto
namespace payments {
class Output;
class OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Payment;
class PaymentDefaultTypeInternal;
extern PaymentDefaultTypeInternal _Payment_default_instance_;
class PaymentACK;
class PaymentACKDefaultTypeInternal;
extern PaymentACKDefaultTypeInternal _PaymentACK_default_instance_;
class PaymentDetails;
class PaymentDetailsDefaultTypeInternal;
extern PaymentDetailsDefaultTypeInternal _PaymentDetails_default_instance_;
class PaymentRequest;
class PaymentRequestDefaultTypeInternal;
extern PaymentRequestDefaultTypeInternal _PaymentRequest_default_instance_;
class X509Certificates;
class X509CertificatesDefaultTypeInternal;
extern X509CertificatesDefaultTypeInternal _X509Certificates_default_instance_;
}  // namespace payments
namespace google {
namespace protobuf {
template<> ::payments::Output* Arena::CreateMaybeMessage<::payments::Output>(Arena*);
template<> ::payments::Payment* Arena::CreateMaybeMessage<::payments::Payment>(Arena*);
template<> ::payments::PaymentACK* Arena::CreateMaybeMessage<::payments::PaymentACK>(Arena*);
template<> ::payments::PaymentDetails* Arena::CreateMaybeMessage<::payments::PaymentDetails>(Arena*);
template<> ::payments::PaymentRequest* Arena::CreateMaybeMessage<::payments::PaymentRequest>(Arena*);
template<> ::payments::X509Certificates* Arena::CreateMaybeMessage<::payments::X509Certificates>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace payments {

// ===================================================================

class Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:payments.Output) */ {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Output* other);
  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Output* New() const final {
    return CreateMaybeMessage<Output>(NULL);
  }

  Output* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes script = 2;
  bool has_script() const;
  void clear_script();
  static const int kScriptFieldNumber = 2;
  const ::std::string& script() const;
  void set_script(const ::std::string& value);
  #if LANG_CXX11
  void set_script(::std::string&& value);
  #endif
  void set_script(const char* value);
  void set_script(const void* value, size_t size);
  ::std::string* mutable_script();
  ::std::string* release_script();
  void set_allocated_script(::std::string* script);

  // optional uint64 amount = 1 [default = 0];
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:payments.Output)
 private:
  void set_has_amount();
  void clear_has_amount();
  void set_has_script();
  void clear_has_script();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr script_;
  ::google::protobuf::uint64 amount_;
  friend struct ::protobuf_paymentrequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PaymentDetails : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:payments.PaymentDetails) */ {
 public:
  PaymentDetails();
  virtual ~PaymentDetails();

  PaymentDetails(const PaymentDetails& from);

  inline PaymentDetails& operator=(const PaymentDetails& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PaymentDetails(PaymentDetails&& from) noexcept
    : PaymentDetails() {
    *this = ::std::move(from);
  }

  inline PaymentDetails& operator=(PaymentDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaymentDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PaymentDetails* internal_default_instance() {
    return reinterpret_cast<const PaymentDetails*>(
               &_PaymentDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PaymentDetails* other);
  friend void swap(PaymentDetails& a, PaymentDetails& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PaymentDetails* New() const final {
    return CreateMaybeMessage<PaymentDetails>(NULL);
  }

  PaymentDetails* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PaymentDetails>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PaymentDetails& from);
  void MergeFrom(const PaymentDetails& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentDetails* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .payments.Output outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  ::payments::Output* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::payments::Output >*
      mutable_outputs();
  const ::payments::Output& outputs(int index) const;
  ::payments::Output* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::payments::Output >&
      outputs() const;

  // optional string network = 1 [default = "main"];
  bool has_network() const;
  void clear_network();
  static const int kNetworkFieldNumber = 1;
  const ::std::string& network() const;
  void set_network(const ::std::string& value);
  #if LANG_CXX11
  void set_network(::std::string&& value);
  #endif
  void set_network(const char* value);
  void set_network(const char* value, size_t size);
  ::std::string* mutable_network();
  ::std::string* release_network();
  void set_allocated_network(::std::string* network);

  // optional string memo = 5;
  bool has_memo() const;
  void clear_memo();
  static const int kMemoFieldNumber = 5;
  const ::std::string& memo() const;
  void set_memo(const ::std::string& value);
  #if LANG_CXX11
  void set_memo(::std::string&& value);
  #endif
  void set_memo(const char* value);
  void set_memo(const char* value, size_t size);
  ::std::string* mutable_memo();
  ::std::string* release_memo();
  void set_allocated_memo(::std::string* memo);

  // optional string payment_url = 6;
  bool has_payment_url() const;
  void clear_payment_url();
  static const int kPaymentUrlFieldNumber = 6;
  const ::std::string& payment_url() const;
  void set_payment_url(const ::std::string& value);
  #if LANG_CXX11
  void set_payment_url(::std::string&& value);
  #endif
  void set_payment_url(const char* value);
  void set_payment_url(const char* value, size_t size);
  ::std::string* mutable_payment_url();
  ::std::string* release_payment_url();
  void set_allocated_payment_url(::std::string* payment_url);

  // optional bytes merchant_data = 7;
  bool has_merchant_data() const;
  void clear_merchant_data();
  static const int kMerchantDataFieldNumber = 7;
  const ::std::string& merchant_data() const;
  void set_merchant_data(const ::std::string& value);
  #if LANG_CXX11
  void set_merchant_data(::std::string&& value);
  #endif
  void set_merchant_data(const char* value);
  void set_merchant_data(const void* value, size_t size);
  ::std::string* mutable_merchant_data();
  ::std::string* release_merchant_data();
  void set_allocated_merchant_data(::std::string* merchant_data);

  // required uint64 time = 3;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // optional uint64 expires = 4;
  bool has_expires() const;
  void clear_expires();
  static const int kExpiresFieldNumber = 4;
  ::google::protobuf::uint64 expires() const;
  void set_expires(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:payments.PaymentDetails)
 private:
  void set_has_network();
  void clear_has_network();
  void set_has_time();
  void clear_has_time();
  void set_has_expires();
  void clear_has_expires();
  void set_has_memo();
  void clear_has_memo();
  void set_has_payment_url();
  void clear_has_payment_url();
  void set_has_merchant_data();
  void clear_has_merchant_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::payments::Output > outputs_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_network_;
  private:
  ::google::protobuf::internal::ArenaStringPtr network_;
  ::google::protobuf::internal::ArenaStringPtr memo_;
  ::google::protobuf::internal::ArenaStringPtr payment_url_;
  ::google::protobuf::internal::ArenaStringPtr merchant_data_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint64 expires_;
  friend struct ::protobuf_paymentrequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PaymentRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:payments.PaymentRequest) */ {
 public:
  PaymentRequest();
  virtual ~PaymentRequest();

  PaymentRequest(const PaymentRequest& from);

  inline PaymentRequest& operator=(const PaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PaymentRequest(PaymentRequest&& from) noexcept
    : PaymentRequest() {
    *this = ::std::move(from);
  }

  inline PaymentRequest& operator=(PaymentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaymentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PaymentRequest* internal_default_instance() {
    return reinterpret_cast<const PaymentRequest*>(
               &_PaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PaymentRequest* other);
  friend void swap(PaymentRequest& a, PaymentRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PaymentRequest* New() const final {
    return CreateMaybeMessage<PaymentRequest>(NULL);
  }

  PaymentRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PaymentRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PaymentRequest& from);
  void MergeFrom(const PaymentRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pki_type = 2 [default = "none"];
  bool has_pki_type() const;
  void clear_pki_type();
  static const int kPkiTypeFieldNumber = 2;
  const ::std::string& pki_type() const;
  void set_pki_type(const ::std::string& value);
  #if LANG_CXX11
  void set_pki_type(::std::string&& value);
  #endif
  void set_pki_type(const char* value);
  void set_pki_type(const char* value, size_t size);
  ::std::string* mutable_pki_type();
  ::std::string* release_pki_type();
  void set_allocated_pki_type(::std::string* pki_type);

  // optional bytes pki_data = 3;
  bool has_pki_data() const;
  void clear_pki_data();
  static const int kPkiDataFieldNumber = 3;
  const ::std::string& pki_data() const;
  void set_pki_data(const ::std::string& value);
  #if LANG_CXX11
  void set_pki_data(::std::string&& value);
  #endif
  void set_pki_data(const char* value);
  void set_pki_data(const void* value, size_t size);
  ::std::string* mutable_pki_data();
  ::std::string* release_pki_data();
  void set_allocated_pki_data(::std::string* pki_data);

  // required bytes serialized_payment_details = 4;
  bool has_serialized_payment_details() const;
  void clear_serialized_payment_details();
  static const int kSerializedPaymentDetailsFieldNumber = 4;
  const ::std::string& serialized_payment_details() const;
  void set_serialized_payment_details(const ::std::string& value);
  #if LANG_CXX11
  void set_serialized_payment_details(::std::string&& value);
  #endif
  void set_serialized_payment_details(const char* value);
  void set_serialized_payment_details(const void* value, size_t size);
  ::std::string* mutable_serialized_payment_details();
  ::std::string* release_serialized_payment_details();
  void set_allocated_serialized_payment_details(::std::string* serialized_payment_details);

  // optional bytes signature = 5;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 5;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional uint32 payment_details_version = 1 [default = 1];
  bool has_payment_details_version() const;
  void clear_payment_details_version();
  static const int kPaymentDetailsVersionFieldNumber = 1;
  ::google::protobuf::uint32 payment_details_version() const;
  void set_payment_details_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:payments.PaymentRequest)
 private:
  void set_has_payment_details_version();
  void clear_has_payment_details_version();
  void set_has_pki_type();
  void clear_has_pki_type();
  void set_has_pki_data();
  void clear_has_pki_data();
  void set_has_serialized_payment_details();
  void clear_has_serialized_payment_details();
  void set_has_signature();
  void clear_has_signature();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_pki_type_;
  private:
  ::google::protobuf::internal::ArenaStringPtr pki_type_;
  ::google::protobuf::internal::ArenaStringPtr pki_data_;
  ::google::protobuf::internal::ArenaStringPtr serialized_payment_details_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::uint32 payment_details_version_;
  friend struct ::protobuf_paymentrequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class X509Certificates : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:payments.X509Certificates) */ {
 public:
  X509Certificates();
  virtual ~X509Certificates();

  X509Certificates(const X509Certificates& from);

  inline X509Certificates& operator=(const X509Certificates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  X509Certificates(X509Certificates&& from) noexcept
    : X509Certificates() {
    *this = ::std::move(from);
  }

  inline X509Certificates& operator=(X509Certificates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const X509Certificates& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const X509Certificates* internal_default_instance() {
    return reinterpret_cast<const X509Certificates*>(
               &_X509Certificates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(X509Certificates* other);
  friend void swap(X509Certificates& a, X509Certificates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline X509Certificates* New() const final {
    return CreateMaybeMessage<X509Certificates>(NULL);
  }

  X509Certificates* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<X509Certificates>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const X509Certificates& from);
  void MergeFrom(const X509Certificates& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(X509Certificates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes certificate = 1;
  int certificate_size() const;
  void clear_certificate();
  static const int kCertificateFieldNumber = 1;
  const ::std::string& certificate(int index) const;
  ::std::string* mutable_certificate(int index);
  void set_certificate(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_certificate(int index, ::std::string&& value);
  #endif
  void set_certificate(int index, const char* value);
  void set_certificate(int index, const void* value, size_t size);
  ::std::string* add_certificate();
  void add_certificate(const ::std::string& value);
  #if LANG_CXX11
  void add_certificate(::std::string&& value);
  #endif
  void add_certificate(const char* value);
  void add_certificate(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& certificate() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_certificate();

  // @@protoc_insertion_point(class_scope:payments.X509Certificates)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> certificate_;
  friend struct ::protobuf_paymentrequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Payment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:payments.Payment) */ {
 public:
  Payment();
  virtual ~Payment();

  Payment(const Payment& from);

  inline Payment& operator=(const Payment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Payment(Payment&& from) noexcept
    : Payment() {
    *this = ::std::move(from);
  }

  inline Payment& operator=(Payment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Payment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Payment* internal_default_instance() {
    return reinterpret_cast<const Payment*>(
               &_Payment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Payment* other);
  friend void swap(Payment& a, Payment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Payment* New() const final {
    return CreateMaybeMessage<Payment>(NULL);
  }

  Payment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Payment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Payment& from);
  void MergeFrom(const Payment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes transactions = 2;
  int transactions_size() const;
  void clear_transactions();
  static const int kTransactionsFieldNumber = 2;
  const ::std::string& transactions(int index) const;
  ::std::string* mutable_transactions(int index);
  void set_transactions(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_transactions(int index, ::std::string&& value);
  #endif
  void set_transactions(int index, const char* value);
  void set_transactions(int index, const void* value, size_t size);
  ::std::string* add_transactions();
  void add_transactions(const ::std::string& value);
  #if LANG_CXX11
  void add_transactions(::std::string&& value);
  #endif
  void add_transactions(const char* value);
  void add_transactions(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& transactions() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_transactions();

  // repeated .payments.Output refund_to = 3;
  int refund_to_size() const;
  void clear_refund_to();
  static const int kRefundToFieldNumber = 3;
  ::payments::Output* mutable_refund_to(int index);
  ::google::protobuf::RepeatedPtrField< ::payments::Output >*
      mutable_refund_to();
  const ::payments::Output& refund_to(int index) const;
  ::payments::Output* add_refund_to();
  const ::google::protobuf::RepeatedPtrField< ::payments::Output >&
      refund_to() const;

  // optional bytes merchant_data = 1;
  bool has_merchant_data() const;
  void clear_merchant_data();
  static const int kMerchantDataFieldNumber = 1;
  const ::std::string& merchant_data() const;
  void set_merchant_data(const ::std::string& value);
  #if LANG_CXX11
  void set_merchant_data(::std::string&& value);
  #endif
  void set_merchant_data(const char* value);
  void set_merchant_data(const void* value, size_t size);
  ::std::string* mutable_merchant_data();
  ::std::string* release_merchant_data();
  void set_allocated_merchant_data(::std::string* merchant_data);

  // optional string memo = 4;
  bool has_memo() const;
  void clear_memo();
  static const int kMemoFieldNumber = 4;
  const ::std::string& memo() const;
  void set_memo(const ::std::string& value);
  #if LANG_CXX11
  void set_memo(::std::string&& value);
  #endif
  void set_memo(const char* value);
  void set_memo(const char* value, size_t size);
  ::std::string* mutable_memo();
  ::std::string* release_memo();
  void set_allocated_memo(::std::string* memo);

  // @@protoc_insertion_point(class_scope:payments.Payment)
 private:
  void set_has_merchant_data();
  void clear_has_merchant_data();
  void set_has_memo();
  void clear_has_memo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> transactions_;
  ::google::protobuf::RepeatedPtrField< ::payments::Output > refund_to_;
  ::google::protobuf::internal::ArenaStringPtr merchant_data_;
  ::google::protobuf::internal::ArenaStringPtr memo_;
  friend struct ::protobuf_paymentrequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PaymentACK : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:payments.PaymentACK) */ {
 public:
  PaymentACK();
  virtual ~PaymentACK();

  PaymentACK(const PaymentACK& from);

  inline PaymentACK& operator=(const PaymentACK& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PaymentACK(PaymentACK&& from) noexcept
    : PaymentACK() {
    *this = ::std::move(from);
  }

  inline PaymentACK& operator=(PaymentACK&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaymentACK& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PaymentACK* internal_default_instance() {
    return reinterpret_cast<const PaymentACK*>(
               &_PaymentACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(PaymentACK* other);
  friend void swap(PaymentACK& a, PaymentACK& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PaymentACK* New() const final {
    return CreateMaybeMessage<PaymentACK>(NULL);
  }

  PaymentACK* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PaymentACK>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PaymentACK& from);
  void MergeFrom(const PaymentACK& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentACK* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string memo = 2;
  bool has_memo() const;
  void clear_memo();
  static const int kMemoFieldNumber = 2;
  const ::std::string& memo() const;
  void set_memo(const ::std::string& value);
  #if LANG_CXX11
  void set_memo(::std::string&& value);
  #endif
  void set_memo(const char* value);
  void set_memo(const char* value, size_t size);
  ::std::string* mutable_memo();
  ::std::string* release_memo();
  void set_allocated_memo(::std::string* memo);

  // required .payments.Payment payment = 1;
  bool has_payment() const;
  void clear_payment();
  static const int kPaymentFieldNumber = 1;
  private:
  const ::payments::Payment& _internal_payment() const;
  public:
  const ::payments::Payment& payment() const;
  ::payments::Payment* release_payment();
  ::payments::Payment* mutable_payment();
  void set_allocated_payment(::payments::Payment* payment);

  // @@protoc_insertion_point(class_scope:payments.PaymentACK)
 private:
  void set_has_payment();
  void clear_has_payment();
  void set_has_memo();
  void clear_has_memo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr memo_;
  ::payments::Payment* payment_;
  friend struct ::protobuf_paymentrequest_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Output

// optional uint64 amount = 1 [default = 0];
inline bool Output::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Output::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Output::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Output::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 Output::amount() const {
  // @@protoc_insertion_point(field_get:payments.Output.amount)
  return amount_;
}
inline void Output::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:payments.Output.amount)
}

// required bytes script = 2;
inline bool Output::has_script() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Output::set_has_script() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Output::clear_has_script() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Output::clear_script() {
  script_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_script();
}
inline const ::std::string& Output::script() const {
  // @@protoc_insertion_point(field_get:payments.Output.script)
  return script_.GetNoArena();
}
inline void Output::set_script(const ::std::string& value) {
  set_has_script();
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payments.Output.script)
}
#if LANG_CXX11
inline void Output::set_script(::std::string&& value) {
  set_has_script();
  script_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.Output.script)
}
#endif
inline void Output::set_script(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_script();
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.Output.script)
}
inline void Output::set_script(const void* value, size_t size) {
  set_has_script();
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.Output.script)
}
inline ::std::string* Output::mutable_script() {
  set_has_script();
  // @@protoc_insertion_point(field_mutable:payments.Output.script)
  return script_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Output::release_script() {
  // @@protoc_insertion_point(field_release:payments.Output.script)
  if (!has_script()) {
    return NULL;
  }
  clear_has_script();
  return script_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Output::set_allocated_script(::std::string* script) {
  if (script != NULL) {
    set_has_script();
  } else {
    clear_has_script();
  }
  script_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), script);
  // @@protoc_insertion_point(field_set_allocated:payments.Output.script)
}

// -------------------------------------------------------------------

// PaymentDetails

// optional string network = 1 [default = "main"];
inline bool PaymentDetails::has_network() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaymentDetails::set_has_network() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaymentDetails::clear_has_network() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaymentDetails::clear_network() {
  network_.ClearToDefaultNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get());
  clear_has_network();
}
inline const ::std::string& PaymentDetails::network() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.network)
  return network_.GetNoArena();
}
inline void PaymentDetails::set_network(const ::std::string& value) {
  set_has_network();
  network_.SetNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get(), value);
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.network)
}
#if LANG_CXX11
inline void PaymentDetails::set_network(::std::string&& value) {
  set_has_network();
  network_.SetNoArena(
    &::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentDetails.network)
}
#endif
inline void PaymentDetails::set_network(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_network();
  network_.SetNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentDetails.network)
}
inline void PaymentDetails::set_network(const char* value, size_t size) {
  set_has_network();
  network_.SetNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentDetails.network)
}
inline ::std::string* PaymentDetails::mutable_network() {
  set_has_network();
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.network)
  return network_.MutableNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get());
}
inline ::std::string* PaymentDetails::release_network() {
  // @@protoc_insertion_point(field_release:payments.PaymentDetails.network)
  if (!has_network()) {
    return NULL;
  }
  clear_has_network();
  return network_.ReleaseNonDefaultNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get());
}
inline void PaymentDetails::set_allocated_network(::std::string* network) {
  if (network != NULL) {
    set_has_network();
  } else {
    clear_has_network();
  }
  network_.SetAllocatedNoArena(&::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_.get(), network);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentDetails.network)
}

// repeated .payments.Output outputs = 2;
inline int PaymentDetails::outputs_size() const {
  return outputs_.size();
}
inline void PaymentDetails::clear_outputs() {
  outputs_.Clear();
}
inline ::payments::Output* PaymentDetails::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::payments::Output >*
PaymentDetails::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:payments.PaymentDetails.outputs)
  return &outputs_;
}
inline const ::payments::Output& PaymentDetails::outputs(int index) const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.outputs)
  return outputs_.Get(index);
}
inline ::payments::Output* PaymentDetails::add_outputs() {
  // @@protoc_insertion_point(field_add:payments.PaymentDetails.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::payments::Output >&
PaymentDetails::outputs() const {
  // @@protoc_insertion_point(field_list:payments.PaymentDetails.outputs)
  return outputs_;
}

// required uint64 time = 3;
inline bool PaymentDetails::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PaymentDetails::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PaymentDetails::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PaymentDetails::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 PaymentDetails::time() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.time)
  return time_;
}
inline void PaymentDetails::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.time)
}

// optional uint64 expires = 4;
inline bool PaymentDetails::has_expires() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PaymentDetails::set_has_expires() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PaymentDetails::clear_has_expires() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PaymentDetails::clear_expires() {
  expires_ = GOOGLE_ULONGLONG(0);
  clear_has_expires();
}
inline ::google::protobuf::uint64 PaymentDetails::expires() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.expires)
  return expires_;
}
inline void PaymentDetails::set_expires(::google::protobuf::uint64 value) {
  set_has_expires();
  expires_ = value;
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.expires)
}

// optional string memo = 5;
inline bool PaymentDetails::has_memo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaymentDetails::set_has_memo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaymentDetails::clear_has_memo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaymentDetails::clear_memo() {
  memo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_memo();
}
inline const ::std::string& PaymentDetails::memo() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.memo)
  return memo_.GetNoArena();
}
inline void PaymentDetails::set_memo(const ::std::string& value) {
  set_has_memo();
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.memo)
}
#if LANG_CXX11
inline void PaymentDetails::set_memo(::std::string&& value) {
  set_has_memo();
  memo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentDetails.memo)
}
#endif
inline void PaymentDetails::set_memo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_memo();
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentDetails.memo)
}
inline void PaymentDetails::set_memo(const char* value, size_t size) {
  set_has_memo();
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentDetails.memo)
}
inline ::std::string* PaymentDetails::mutable_memo() {
  set_has_memo();
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.memo)
  return memo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PaymentDetails::release_memo() {
  // @@protoc_insertion_point(field_release:payments.PaymentDetails.memo)
  if (!has_memo()) {
    return NULL;
  }
  clear_has_memo();
  return memo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentDetails::set_allocated_memo(::std::string* memo) {
  if (memo != NULL) {
    set_has_memo();
  } else {
    clear_has_memo();
  }
  memo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memo);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentDetails.memo)
}

// optional string payment_url = 6;
inline bool PaymentDetails::has_payment_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaymentDetails::set_has_payment_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaymentDetails::clear_has_payment_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaymentDetails::clear_payment_url() {
  payment_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payment_url();
}
inline const ::std::string& PaymentDetails::payment_url() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.payment_url)
  return payment_url_.GetNoArena();
}
inline void PaymentDetails::set_payment_url(const ::std::string& value) {
  set_has_payment_url();
  payment_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.payment_url)
}
#if LANG_CXX11
inline void PaymentDetails::set_payment_url(::std::string&& value) {
  set_has_payment_url();
  payment_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentDetails.payment_url)
}
#endif
inline void PaymentDetails::set_payment_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payment_url();
  payment_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentDetails.payment_url)
}
inline void PaymentDetails::set_payment_url(const char* value, size_t size) {
  set_has_payment_url();
  payment_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentDetails.payment_url)
}
inline ::std::string* PaymentDetails::mutable_payment_url() {
  set_has_payment_url();
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.payment_url)
  return payment_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PaymentDetails::release_payment_url() {
  // @@protoc_insertion_point(field_release:payments.PaymentDetails.payment_url)
  if (!has_payment_url()) {
    return NULL;
  }
  clear_has_payment_url();
  return payment_url_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentDetails::set_allocated_payment_url(::std::string* payment_url) {
  if (payment_url != NULL) {
    set_has_payment_url();
  } else {
    clear_has_payment_url();
  }
  payment_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payment_url);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentDetails.payment_url)
}

// optional bytes merchant_data = 7;
inline bool PaymentDetails::has_merchant_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PaymentDetails::set_has_merchant_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PaymentDetails::clear_has_merchant_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PaymentDetails::clear_merchant_data() {
  merchant_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_merchant_data();
}
inline const ::std::string& PaymentDetails::merchant_data() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.merchant_data)
  return merchant_data_.GetNoArena();
}
inline void PaymentDetails::set_merchant_data(const ::std::string& value) {
  set_has_merchant_data();
  merchant_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.merchant_data)
}
#if LANG_CXX11
inline void PaymentDetails::set_merchant_data(::std::string&& value) {
  set_has_merchant_data();
  merchant_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentDetails.merchant_data)
}
#endif
inline void PaymentDetails::set_merchant_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_merchant_data();
  merchant_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentDetails.merchant_data)
}
inline void PaymentDetails::set_merchant_data(const void* value, size_t size) {
  set_has_merchant_data();
  merchant_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentDetails.merchant_data)
}
inline ::std::string* PaymentDetails::mutable_merchant_data() {
  set_has_merchant_data();
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.merchant_data)
  return merchant_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PaymentDetails::release_merchant_data() {
  // @@protoc_insertion_point(field_release:payments.PaymentDetails.merchant_data)
  if (!has_merchant_data()) {
    return NULL;
  }
  clear_has_merchant_data();
  return merchant_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentDetails::set_allocated_merchant_data(::std::string* merchant_data) {
  if (merchant_data != NULL) {
    set_has_merchant_data();
  } else {
    clear_has_merchant_data();
  }
  merchant_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), merchant_data);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentDetails.merchant_data)
}

// -------------------------------------------------------------------

// PaymentRequest

// optional uint32 payment_details_version = 1 [default = 1];
inline bool PaymentRequest::has_payment_details_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PaymentRequest::set_has_payment_details_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PaymentRequest::clear_has_payment_details_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PaymentRequest::clear_payment_details_version() {
  payment_details_version_ = 1u;
  clear_has_payment_details_version();
}
inline ::google::protobuf::uint32 PaymentRequest::payment_details_version() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.payment_details_version)
  return payment_details_version_;
}
inline void PaymentRequest::set_payment_details_version(::google::protobuf::uint32 value) {
  set_has_payment_details_version();
  payment_details_version_ = value;
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.payment_details_version)
}

// optional string pki_type = 2 [default = "none"];
inline bool PaymentRequest::has_pki_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaymentRequest::set_has_pki_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaymentRequest::clear_has_pki_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaymentRequest::clear_pki_type() {
  pki_type_.ClearToDefaultNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get());
  clear_has_pki_type();
}
inline const ::std::string& PaymentRequest::pki_type() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.pki_type)
  return pki_type_.GetNoArena();
}
inline void PaymentRequest::set_pki_type(const ::std::string& value) {
  set_has_pki_type();
  pki_type_.SetNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get(), value);
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.pki_type)
}
#if LANG_CXX11
inline void PaymentRequest::set_pki_type(::std::string&& value) {
  set_has_pki_type();
  pki_type_.SetNoArena(
    &::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentRequest.pki_type)
}
#endif
inline void PaymentRequest::set_pki_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pki_type();
  pki_type_.SetNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentRequest.pki_type)
}
inline void PaymentRequest::set_pki_type(const char* value, size_t size) {
  set_has_pki_type();
  pki_type_.SetNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentRequest.pki_type)
}
inline ::std::string* PaymentRequest::mutable_pki_type() {
  set_has_pki_type();
  // @@protoc_insertion_point(field_mutable:payments.PaymentRequest.pki_type)
  return pki_type_.MutableNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get());
}
inline ::std::string* PaymentRequest::release_pki_type() {
  // @@protoc_insertion_point(field_release:payments.PaymentRequest.pki_type)
  if (!has_pki_type()) {
    return NULL;
  }
  clear_has_pki_type();
  return pki_type_.ReleaseNonDefaultNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get());
}
inline void PaymentRequest::set_allocated_pki_type(::std::string* pki_type) {
  if (pki_type != NULL) {
    set_has_pki_type();
  } else {
    clear_has_pki_type();
  }
  pki_type_.SetAllocatedNoArena(&::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_.get(), pki_type);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentRequest.pki_type)
}

// optional bytes pki_data = 3;
inline bool PaymentRequest::has_pki_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaymentRequest::set_has_pki_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaymentRequest::clear_has_pki_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaymentRequest::clear_pki_data() {
  pki_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pki_data();
}
inline const ::std::string& PaymentRequest::pki_data() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.pki_data)
  return pki_data_.GetNoArena();
}
inline void PaymentRequest::set_pki_data(const ::std::string& value) {
  set_has_pki_data();
  pki_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.pki_data)
}
#if LANG_CXX11
inline void PaymentRequest::set_pki_data(::std::string&& value) {
  set_has_pki_data();
  pki_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentRequest.pki_data)
}
#endif
inline void PaymentRequest::set_pki_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pki_data();
  pki_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentRequest.pki_data)
}
inline void PaymentRequest::set_pki_data(const void* value, size_t size) {
  set_has_pki_data();
  pki_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentRequest.pki_data)
}
inline ::std::string* PaymentRequest::mutable_pki_data() {
  set_has_pki_data();
  // @@protoc_insertion_point(field_mutable:payments.PaymentRequest.pki_data)
  return pki_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PaymentRequest::release_pki_data() {
  // @@protoc_insertion_point(field_release:payments.PaymentRequest.pki_data)
  if (!has_pki_data()) {
    return NULL;
  }
  clear_has_pki_data();
  return pki_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentRequest::set_allocated_pki_data(::std::string* pki_data) {
  if (pki_data != NULL) {
    set_has_pki_data();
  } else {
    clear_has_pki_data();
  }
  pki_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pki_data);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentRequest.pki_data)
}

// required bytes serialized_payment_details = 4;
inline bool PaymentRequest::has_serialized_payment_details() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaymentRequest::set_has_serialized_payment_details() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaymentRequest::clear_has_serialized_payment_details() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaymentRequest::clear_serialized_payment_details() {
  serialized_payment_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serialized_payment_details();
}
inline const ::std::string& PaymentRequest::serialized_payment_details() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.serialized_payment_details)
  return serialized_payment_details_.GetNoArena();
}
inline void PaymentRequest::set_serialized_payment_details(const ::std::string& value) {
  set_has_serialized_payment_details();
  serialized_payment_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.serialized_payment_details)
}
#if LANG_CXX11
inline void PaymentRequest::set_serialized_payment_details(::std::string&& value) {
  set_has_serialized_payment_details();
  serialized_payment_details_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentRequest.serialized_payment_details)
}
#endif
inline void PaymentRequest::set_serialized_payment_details(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serialized_payment_details();
  serialized_payment_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentRequest.serialized_payment_details)
}
inline void PaymentRequest::set_serialized_payment_details(const void* value, size_t size) {
  set_has_serialized_payment_details();
  serialized_payment_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentRequest.serialized_payment_details)
}
inline ::std::string* PaymentRequest::mutable_serialized_payment_details() {
  set_has_serialized_payment_details();
  // @@protoc_insertion_point(field_mutable:payments.PaymentRequest.serialized_payment_details)
  return serialized_payment_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PaymentRequest::release_serialized_payment_details() {
  // @@protoc_insertion_point(field_release:payments.PaymentRequest.serialized_payment_details)
  if (!has_serialized_payment_details()) {
    return NULL;
  }
  clear_has_serialized_payment_details();
  return serialized_payment_details_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentRequest::set_allocated_serialized_payment_details(::std::string* serialized_payment_details) {
  if (serialized_payment_details != NULL) {
    set_has_serialized_payment_details();
  } else {
    clear_has_serialized_payment_details();
  }
  serialized_payment_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serialized_payment_details);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentRequest.serialized_payment_details)
}

// optional bytes signature = 5;
inline bool PaymentRequest::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PaymentRequest::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PaymentRequest::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PaymentRequest::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& PaymentRequest::signature() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.signature)
  return signature_.GetNoArena();
}
inline void PaymentRequest::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.signature)
}
#if LANG_CXX11
inline void PaymentRequest::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentRequest.signature)
}
#endif
inline void PaymentRequest::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentRequest.signature)
}
inline void PaymentRequest::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentRequest.signature)
}
inline ::std::string* PaymentRequest::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:payments.PaymentRequest.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PaymentRequest::release_signature() {
  // @@protoc_insertion_point(field_release:payments.PaymentRequest.signature)
  if (!has_signature()) {
    return NULL;
  }
  clear_has_signature();
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentRequest::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentRequest.signature)
}

// -------------------------------------------------------------------

// X509Certificates

// repeated bytes certificate = 1;
inline int X509Certificates::certificate_size() const {
  return certificate_.size();
}
inline void X509Certificates::clear_certificate() {
  certificate_.Clear();
}
inline const ::std::string& X509Certificates::certificate(int index) const {
  // @@protoc_insertion_point(field_get:payments.X509Certificates.certificate)
  return certificate_.Get(index);
}
inline ::std::string* X509Certificates::mutable_certificate(int index) {
  // @@protoc_insertion_point(field_mutable:payments.X509Certificates.certificate)
  return certificate_.Mutable(index);
}
inline void X509Certificates::set_certificate(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:payments.X509Certificates.certificate)
  certificate_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void X509Certificates::set_certificate(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:payments.X509Certificates.certificate)
  certificate_.Mutable(index)->assign(std::move(value));
}
#endif
inline void X509Certificates::set_certificate(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  certificate_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:payments.X509Certificates.certificate)
}
inline void X509Certificates::set_certificate(int index, const void* value, size_t size) {
  certificate_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:payments.X509Certificates.certificate)
}
inline ::std::string* X509Certificates::add_certificate() {
  // @@protoc_insertion_point(field_add_mutable:payments.X509Certificates.certificate)
  return certificate_.Add();
}
inline void X509Certificates::add_certificate(const ::std::string& value) {
  certificate_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:payments.X509Certificates.certificate)
}
#if LANG_CXX11
inline void X509Certificates::add_certificate(::std::string&& value) {
  certificate_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:payments.X509Certificates.certificate)
}
#endif
inline void X509Certificates::add_certificate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  certificate_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:payments.X509Certificates.certificate)
}
inline void X509Certificates::add_certificate(const void* value, size_t size) {
  certificate_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:payments.X509Certificates.certificate)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
X509Certificates::certificate() const {
  // @@protoc_insertion_point(field_list:payments.X509Certificates.certificate)
  return certificate_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
X509Certificates::mutable_certificate() {
  // @@protoc_insertion_point(field_mutable_list:payments.X509Certificates.certificate)
  return &certificate_;
}

// -------------------------------------------------------------------

// Payment

// optional bytes merchant_data = 1;
inline bool Payment::has_merchant_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Payment::set_has_merchant_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Payment::clear_has_merchant_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Payment::clear_merchant_data() {
  merchant_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_merchant_data();
}
inline const ::std::string& Payment::merchant_data() const {
  // @@protoc_insertion_point(field_get:payments.Payment.merchant_data)
  return merchant_data_.GetNoArena();
}
inline void Payment::set_merchant_data(const ::std::string& value) {
  set_has_merchant_data();
  merchant_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payments.Payment.merchant_data)
}
#if LANG_CXX11
inline void Payment::set_merchant_data(::std::string&& value) {
  set_has_merchant_data();
  merchant_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.Payment.merchant_data)
}
#endif
inline void Payment::set_merchant_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_merchant_data();
  merchant_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.Payment.merchant_data)
}
inline void Payment::set_merchant_data(const void* value, size_t size) {
  set_has_merchant_data();
  merchant_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.Payment.merchant_data)
}
inline ::std::string* Payment::mutable_merchant_data() {
  set_has_merchant_data();
  // @@protoc_insertion_point(field_mutable:payments.Payment.merchant_data)
  return merchant_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Payment::release_merchant_data() {
  // @@protoc_insertion_point(field_release:payments.Payment.merchant_data)
  if (!has_merchant_data()) {
    return NULL;
  }
  clear_has_merchant_data();
  return merchant_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Payment::set_allocated_merchant_data(::std::string* merchant_data) {
  if (merchant_data != NULL) {
    set_has_merchant_data();
  } else {
    clear_has_merchant_data();
  }
  merchant_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), merchant_data);
  // @@protoc_insertion_point(field_set_allocated:payments.Payment.merchant_data)
}

// repeated bytes transactions = 2;
inline int Payment::transactions_size() const {
  return transactions_.size();
}
inline void Payment::clear_transactions() {
  transactions_.Clear();
}
inline const ::std::string& Payment::transactions(int index) const {
  // @@protoc_insertion_point(field_get:payments.Payment.transactions)
  return transactions_.Get(index);
}
inline ::std::string* Payment::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:payments.Payment.transactions)
  return transactions_.Mutable(index);
}
inline void Payment::set_transactions(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:payments.Payment.transactions)
  transactions_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Payment::set_transactions(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:payments.Payment.transactions)
  transactions_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Payment::set_transactions(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  transactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:payments.Payment.transactions)
}
inline void Payment::set_transactions(int index, const void* value, size_t size) {
  transactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:payments.Payment.transactions)
}
inline ::std::string* Payment::add_transactions() {
  // @@protoc_insertion_point(field_add_mutable:payments.Payment.transactions)
  return transactions_.Add();
}
inline void Payment::add_transactions(const ::std::string& value) {
  transactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:payments.Payment.transactions)
}
#if LANG_CXX11
inline void Payment::add_transactions(::std::string&& value) {
  transactions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:payments.Payment.transactions)
}
#endif
inline void Payment::add_transactions(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  transactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:payments.Payment.transactions)
}
inline void Payment::add_transactions(const void* value, size_t size) {
  transactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:payments.Payment.transactions)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Payment::transactions() const {
  // @@protoc_insertion_point(field_list:payments.Payment.transactions)
  return transactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Payment::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:payments.Payment.transactions)
  return &transactions_;
}

// repeated .payments.Output refund_to = 3;
inline int Payment::refund_to_size() const {
  return refund_to_.size();
}
inline void Payment::clear_refund_to() {
  refund_to_.Clear();
}
inline ::payments::Output* Payment::mutable_refund_to(int index) {
  // @@protoc_insertion_point(field_mutable:payments.Payment.refund_to)
  return refund_to_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::payments::Output >*
Payment::mutable_refund_to() {
  // @@protoc_insertion_point(field_mutable_list:payments.Payment.refund_to)
  return &refund_to_;
}
inline const ::payments::Output& Payment::refund_to(int index) const {
  // @@protoc_insertion_point(field_get:payments.Payment.refund_to)
  return refund_to_.Get(index);
}
inline ::payments::Output* Payment::add_refund_to() {
  // @@protoc_insertion_point(field_add:payments.Payment.refund_to)
  return refund_to_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::payments::Output >&
Payment::refund_to() const {
  // @@protoc_insertion_point(field_list:payments.Payment.refund_to)
  return refund_to_;
}

// optional string memo = 4;
inline bool Payment::has_memo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Payment::set_has_memo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Payment::clear_has_memo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Payment::clear_memo() {
  memo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_memo();
}
inline const ::std::string& Payment::memo() const {
  // @@protoc_insertion_point(field_get:payments.Payment.memo)
  return memo_.GetNoArena();
}
inline void Payment::set_memo(const ::std::string& value) {
  set_has_memo();
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payments.Payment.memo)
}
#if LANG_CXX11
inline void Payment::set_memo(::std::string&& value) {
  set_has_memo();
  memo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.Payment.memo)
}
#endif
inline void Payment::set_memo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_memo();
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.Payment.memo)
}
inline void Payment::set_memo(const char* value, size_t size) {
  set_has_memo();
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.Payment.memo)
}
inline ::std::string* Payment::mutable_memo() {
  set_has_memo();
  // @@protoc_insertion_point(field_mutable:payments.Payment.memo)
  return memo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Payment::release_memo() {
  // @@protoc_insertion_point(field_release:payments.Payment.memo)
  if (!has_memo()) {
    return NULL;
  }
  clear_has_memo();
  return memo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Payment::set_allocated_memo(::std::string* memo) {
  if (memo != NULL) {
    set_has_memo();
  } else {
    clear_has_memo();
  }
  memo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memo);
  // @@protoc_insertion_point(field_set_allocated:payments.Payment.memo)
}

// -------------------------------------------------------------------

// PaymentACK

// required .payments.Payment payment = 1;
inline bool PaymentACK::has_payment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaymentACK::set_has_payment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaymentACK::clear_has_payment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaymentACK::clear_payment() {
  if (payment_ != NULL) payment_->Clear();
  clear_has_payment();
}
inline const ::payments::Payment& PaymentACK::_internal_payment() const {
  return *payment_;
}
inline const ::payments::Payment& PaymentACK::payment() const {
  const ::payments::Payment* p = payment_;
  // @@protoc_insertion_point(field_get:payments.PaymentACK.payment)
  return p != NULL ? *p : *reinterpret_cast<const ::payments::Payment*>(
      &::payments::_Payment_default_instance_);
}
inline ::payments::Payment* PaymentACK::release_payment() {
  // @@protoc_insertion_point(field_release:payments.PaymentACK.payment)
  clear_has_payment();
  ::payments::Payment* temp = payment_;
  payment_ = NULL;
  return temp;
}
inline ::payments::Payment* PaymentACK::mutable_payment() {
  set_has_payment();
  if (payment_ == NULL) {
    auto* p = CreateMaybeMessage<::payments::Payment>(GetArenaNoVirtual());
    payment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:payments.PaymentACK.payment)
  return payment_;
}
inline void PaymentACK::set_allocated_payment(::payments::Payment* payment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete payment_;
  }
  if (payment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      payment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    set_has_payment();
  } else {
    clear_has_payment();
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentACK.payment)
}

// optional string memo = 2;
inline bool PaymentACK::has_memo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaymentACK::set_has_memo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaymentACK::clear_has_memo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaymentACK::clear_memo() {
  memo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_memo();
}
inline const ::std::string& PaymentACK::memo() const {
  // @@protoc_insertion_point(field_get:payments.PaymentACK.memo)
  return memo_.GetNoArena();
}
inline void PaymentACK::set_memo(const ::std::string& value) {
  set_has_memo();
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payments.PaymentACK.memo)
}
#if LANG_CXX11
inline void PaymentACK::set_memo(::std::string&& value) {
  set_has_memo();
  memo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:payments.PaymentACK.memo)
}
#endif
inline void PaymentACK::set_memo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_memo();
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payments.PaymentACK.memo)
}
inline void PaymentACK::set_memo(const char* value, size_t size) {
  set_has_memo();
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payments.PaymentACK.memo)
}
inline ::std::string* PaymentACK::mutable_memo() {
  set_has_memo();
  // @@protoc_insertion_point(field_mutable:payments.PaymentACK.memo)
  return memo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PaymentACK::release_memo() {
  // @@protoc_insertion_point(field_release:payments.PaymentACK.memo)
  if (!has_memo()) {
    return NULL;
  }
  clear_has_memo();
  return memo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentACK::set_allocated_memo(::std::string* memo) {
  if (memo != NULL) {
    set_has_memo();
  } else {
    clear_has_memo();
  }
  memo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memo);
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentACK.memo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace payments

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_paymentrequest_2eproto
